#!/usr/bin/python3

import time
from typing import Dict, Any
from libby.daemon import LibbyDaemon
from hispec.util.thorlabs.fw102c import FilterWheelController
import configparser

def connect(controller: FilterWheelController):
    #handles connection
    try:
        controller.connect()
    except exception as e:
        return {"Connect": "Failed"}
    return {"Connect": "Success"}

def disconnect(controller: FilterWheelController):
    #handles disconnection
    try:
        controller.disconnect()
    except exception as e:
        return {"Disconnect": "Failed"}
    return {"Disconnect": "Success"}

def initialize(controller: FilterWheelController):
    #handles initialization
    try:
        controller.initialize()
    except exception as e:
        return {"Initialize": "Failed"}
    return {"Initialize": "Success"}

def status(controller: FilterWheelController):
    #handles status
    return {"Status": controller.status()}

def get_position(controller: FilterWheelController):
    #gets current position
    return {"Position": controller.get_position()}

def set_position(controller: FilterWheelController, position: int):
    #sets current position
    try:
        controller.move(position)
    except exception as e:
        return {"Move": "Failed"}
    return {"Move": "Success"}


class hkcalfwheel1(LibbyDaemon):
    peer_id = "hkcalfwheel1"
    bind = "tcp://*:5555"
    address_book = {
        #"hkcalfwheel2": "tcp://192.168.29.:5555",
        "pi_1_daemon": "tcp://131.215.200.218:5560"
    }
    discovery_enabled = True
    discovery_interval_s = 2.0

    services = {
        "connect":      connect,
        "disconnect":   disconnect,
        "initialize":   inicialize,
        "status":       status,
        "get.position": get_position,
        "set.position": set_position
    }

    def on_start(self, libby):
        # Proxy service needing live libby handle
        def echo_proxy(_p: Dict[str, Any]):
            res = libby.rpc("peer-B", "perf.echo", {"t0": time.time()}, ttl_ms=6000)
            return {"ok": True, "forwarded_to": "peer-B", "result": res}

        self.add_service("perf.echo.proxy", echo_proxy)

        print("[hkcalfwheel1] math.add(2,5) ->",
              libby.rpc(self.peer_id, "math.add", {"a": 2, "b": 5}, ttl_ms=2000))

        libby.publish("alerts.status", {"source": "peer-C", "ok": True})

    def on_start(self, libby):
        #on start set up the daemon from config and initialize device
        with open('hscal.config', 'r') as config:
            self.ip = config["Device Control"]["hkcalfwheel1_ip"]
            self.port = config["Device Control"]["hkcalfwheel1_port"]
        self.dev = FilterWheelController()
        self.dev.set_connection(ip = self.ip, port = self.port)
        try:
            self.dev.connect()
            self.dev.inicialize() 
            #publish to libby
            libby.publish("hkcalfwheel", {"Daemon Startup": "Success"})
        except exception as e:
            #publish failure
            libby.publish("hkcalfwheel", {"Daemon Startup": "Failed", "Connection Error": f"{e}"})
    
    def on_stop(self, libby):
        #Disconnect and let user know
        try:
            self.dev.disconnect()
            libby.publish("hkcalfwheel", {"Daemon Shutdown": "Success"})
        except exception as e:
            libby.publish("hkcalfwheel", {"Daemon Startup": "Failed", "Error":f"{e}"})

    def on_req(key: str, payload: Dict[str, Any], ctx: Dict[str, Any]) -> Dict[str, Any]:
        #set up pipe to functions that execute controls
        pos = int(payload.get("position")) if "position" in payload else None
        try:
            match key:
                case "connect":
                    return {"connect":connect(self.dev),"t0": t0, "t1": time.time(), "from": ctx["source"]}
                case "disconnect":
                    return {"disconnect":disconnect(self.dev), "t0": t0, "t1": time.time(), "from": ctx["source"]}
                case "initialize":
                    return {"initialize":initialize(self.dev), "t0": t0, "t1": time.time(), "from": ctx["source"]}
                case "status":
                    return {"status":status(self.dev), "t0": t0, "t1": time.time(), "from": ctx["source"]}
                case "get.position":
                    return {"get_position":get_position(self.dev, ), "t0": t0, "t1": time.time(), "from": ctx["source"]}
                case "set.position":
                    return {"set_position":set_position(self.dev, pos), "t0": t0, "t1": time.time(), "from": ctx["source"]}
                case _:
                    return {"ok": False, "error": f"unknown key {key}"}
        except exception as e:
            return {"ok": False,"t0": t0, "t1": time.time(), "error": f"Exception {e} during handling of key {key}"}


if __name__ == "__main__":
    hkcalfwheel1().serve()