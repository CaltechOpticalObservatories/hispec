#!/usr/bin/env python3
"""
    atcpress - Daemon class for atcpress
"""
import sys
from typing import Dict, Any
import configparser
from libby.daemon import LibbyDaemon
from hispec.util.inficon.inficonvgc502 import InficonVGC502

def connect(controller: InficonVGC502, host:str, port:int):
    """handles connection"""
    controller.connect(host, port)
    if controller.is_connected():
        return {"Connect": "Success"}
    return {"error": "Connect Failed"}

def disconnect(controller: InficonVGC502):
    """handles disconnection"""
    controller.disconnect()
    if controller.is_connected():
        return {"error": "Disconnect failed"}
    return {"Disconnect": "Success"}

def get_data(controller: InficonVGC502, item:str) -> Dict[str, Any]:
    """handles getting data"""

    controller_data = controller.get_atomic_value(item)
    if controller_data == sys.float_info.max:
        return {"error": "Data not acquired"}
    return {"sensor_data": controller_data}

def set_pressure_unit(controller: InficonVGC502, unit_code:int =1) -> Dict[str, Any]:
    """handles setting pressure unit

    :param controller: InficonVGC502 object
    :param unit_code: 0 - mbar, 1 - Torr, 2 - Pascal, 3 - Micron, 4 - hPascal, 5 - Volt
    """
    if controller.set_pressure_unit(unit_code):
        return {"Punit": controller.get_pressure_unit()}
    return {"error": "Pressure unit not set"}


class AtcPress(LibbyDaemon):
    """ Daemon class for atcpress """
    peer_id = "atcpress"
    bind = "tcp://*:5555"
    address_book = {
        #"atcpress": "tcp://192.168.29.:5555",
        "pi_1_daemon": "tcp://131.215.200.218:5560"
    }
    dev = None
    host = None
    port = None
    discovery_enabled = True
    discovery_interval_s = 2.0

    services = {
        "connect":      connect,
        "disconnect":   disconnect,
        "get.data":     get_data,
        "set.units":    set_pressure_unit
    }

    def _must(self, name:str):
        """ checks if the given name exists """
        if "bind" in name:
            return self.bind
        if "address_book" in name:
            return self.address_book
        if "peer_id" in name:
            return self.peer_id
        return None

    def on_start(self, libby):
        """on start set up the daemon from config and initialize device"""
        cfg = configparser.ConfigParser()
        cfg.read("hsmet.conf")
        self.host = cfg.get("Device Control", "atcpress_host")
        self.port = int(cfg.get("Device Control", "atcpress_port"))
        self.dev = InficonVGC502()
        self.dev.connect(self.host, self.port)
        if self.dev.is_connected():
            #publish to libby
            libby.publish("atcpress", {"Daemon Startup": "Success"})
        else:
            libby.publish("atcpress", {"Daemon Startup": "Failed"})

    def on_stop(self, libby):
        """Disconnect and let user know"""
        self.dev.disconnect()
        if self.dev.is_connected():
            libby.publish("atcpress", {"Daemon Shutdown": "Failed"})
        else:
            libby.publish("atcpress", {"Daemon Shutdown": "Success"})

    def on_req(self, key: str, payload: Dict[str, Any], ctx: Dict[str, Any]) -> Dict[str, Any]:
        """ set up pipe to functions that execute controls """
        item = payload.get("item") if "item" in payload else None
        unit_code = payload.get("unit_code") if "unit_code" in payload else None
        try:
            match key:
                case "connect":
                    return {"connect":connect(self.dev, self.host, self.port),
                            "from": ctx["source"]}
                case "disconnect":
                    return {"disconnect":disconnect(self.dev), "from": ctx["source"]}
                case "get.data":
                    return {"get_data":get_data(self.dev, item), "from": ctx["source"]}
                case "set.units":
                    return {"set_units": set_pressure_unit(self.dev, unit_code),
                            "from": ctx["source"]}
                case _:
                    return {"ok": False, "error": f"unknown key {key}"}
        except Exception as e:
            return {"ok": False,
                    "error": f"Exception {e} during handling of key {key}"}


if __name__ == "__main__":
    atcpress = AtcPress()
    atcpress.serve()
