#!/usr/bin/python3.12
'''Module for the BLUE YJ PIAA Gimbal Daemon'''
import argparse
import sys
from typing import Dict, Any #pylint: disable = W0611

from hispec.daemon import HispecDaemon #pylint: disable = E0401,E0611
from hispec.util.thorlabs.ppc102 import Ppc102Controller #pylint: disable = E0401,E0611
#from ppc102 import Ppc102Controller  # Assuming ppc102.py is in the same directory

class Yjpiaagim(HispecDaemon): #pylint: disable = W0223
    '''Daemon for controlling the ATC Filter Wheel via Thorlabs FW102C controller'''

    # Defaults
    peer_id = "yjpiaagim"
    group_id = "hsfei"
    transport = "rabbitmq"
    discovery_enabled = False
    rabbitmq_url = "amqp://localhost"  # RabbitMQ on hispec
    daemon_desc = "YJ Piaa Gimbal"

    # pub/sub topics
    topics = {}

    def __init__(self):
        """Initialize the Blue PIAA Gimbal daemon.

        Args: come from the hsfei configuration file
        """
        super().__init__()


        #load configuration from hsfei.yaml
        self.host = self.get_config("hardware.host", "192.168.29.100")
        self.port = self.get_config("hardware.port", 10010)
        self.device_key = None

        self.dev = Ppc102Controller(log = True)

        # Daemon state
        self.state = {
            'connected': False,
            'error': ''
        }

    def on_start(self, libby):
        '''Starts up daemon and initializies the hardware device'''
        self.logger.info("Starting %s Daemon", self.daemon_desc)
        self.add_services({
            "connect":      lambda p: self.connect(),
            "disconnect":   lambda p: self.disconnect(),
            "initialize":   lambda p: self.initialize(),
            "status":       lambda p: self.status(),
            "is_loops_closed": lambda p: self.is_loops_closed(),
            "close_loops":  lambda p: self.close_loops(),
            "open_loops":   lambda p: self.open_loops(),
            "position.get": lambda p: self.get_pos(),
            "position.set": lambda p: self.set_pos(axis = p.get("axis"),
                                                   pos = p.get("position")),
            "position.get_named": lambda p: self.get_named_position(),
            "position.set_named": lambda p: self.goto_named_pos(name = p.get("named_pos"))
        })
        try:
            self.connect()
            self.logger.info("Connected to %s", self.daemon_desc)
            self.initialize()
            self.logger.info("Initialized %s", self.daemon_desc)
            self.load_named_pos()
            #publish to libby
            libby.publish("yjpiaagim", {"Daemon Startup": "Success"})
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error Connecting and Initializing %s: %s", self.daemon_desc, e)
            #publish failure
            libby.publish("yjpiaagim", {"Daemon Startup": "Failed", "Connection Error": f"{e}"})

    def on_stop(self, libby) -> None: #pylint: disable=W0222
        '''Stops the daemon and disconnects from hardware device'''
        try:
            self.disconnect()
            self.logger.info("Disconnected %s", self.daemon_desc)
            libby.publish("yjpiaagim", {"Daemon Shutdown": "Success"})
        except Exception as e: # pylint: disable=W0718
            libby.publish("yjpiaagim", {"Daemon Startup": "Failed", "Error":f"{e}"})
            self.logger.error("Disconnect %s:: Failed ", self.daemon_desc)


    def connect(self):
        """handles connection"""
        try:
            self.dev.connect(host = self.host, port = self.port)
            self.logger.info("Connected %s", self.daemon_desc)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Connect": "Failed", "Error": f"{e}"}
        return {"Connect": "Success"}

    def disconnect(self):
        """handles disconnection"""
        try:
            self.dev.disconnect()
            self.logger.info("Disconnected from %s", self.daemon_desc)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Disconnect": "Failed", "Error": f"{e}"}
        return {"Disconnect": "Success"}

    def initialize(self):
        """handles initialization"""
        # for PPC102_Coms, this involves setting the enable
        try:
            self.dev.set_enable(channel = 0, enable = 1)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Initialize": "Failed", "Error": f"{e}"}
        return {"Initialize": "Success"}

    def load_named_pos(self):
        """loads named positions into the device from config file"""
        config = configparser.ConfigParser()
        config.read('hsfei.config')
        try:
            for name, pos in config["yjpiaagim-named_pos"].items():
                self.named_positions[name] = tuple(map(float, pos.split(",")))
            self.logger.info("Loaded named positions for %s", self.daemon_desc)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Load Named Positions": "Failed", "Error": f"{e}"}
        return {"Load Named Positions": "Success"}

    def status(self): #TODO: Check to make sure this is correct for PPC102 
        """handles status"""
        try:
            status = self.dev.get_status_update()
            self.logger.debug("status: %s",status)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"status": "Failed", "Error": f"{e}"}
        return {"status": status}

    def is_loops_closed(self):
        '''checks if loops are closed'''
        try:
            closed = self.dev.is_loop_closed()
            self.logger.debug("is_loops_closed: %s",closed)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"is_loops_closed": "Failed", "Error": f"{e}"}
        return {"loops_closed": str(closed)}
    
    def close_loops(self):
        '''closes control loops'''
        try:
            self.dev.set_loop(channel=0, loop=2)
            self.logger.debug("close_loops called")
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"close_loops": "Failed", "Error": f"{e}"}
        return {"close_loops": "Success"}

    def open_loops(self):
        '''opens control loops'''
        try:
            self.dev.set_loop(channel=0, loop=1)
            self.logger.debug("open_loops called")
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"open_loops": "Failed", "Error": f"{e}"}
        return {"open_loops": "Success"}

    def get_pos(self):
        '''gets current position'''
        try:
            xpos = self.dev.get_pos(channel=1)
            ypos = self.dev.get_pos(channel=2)
            position = (xpos, ypos)
            self.logger.debug("get_pos: %s",position)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"get_pos": "Failed", "Error": f"{e}"}
        return {"position": str(position)}

    def set_pos(self, axis, pos):
        '''sets current position'''
        try:
            pos = float(pos)
            axis = int(axis)
            if axis not in [0,1]:
                self.logger.error("Axis must be 0 (X) or 1 (Y)")
                return {"Move": "Failed", "Error": "Axis must be 0 (X) or 1 (Y)"}
            chan = axis + 1
            self.dev.set_pos(channel=chan, pos=pos)
            self.logger.debug("set_pos: %d",pos)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Move": "Failed", "Error": f"{e}"}
        return {"Move": "Success"}

    def goto_named_pos(self, name):
        '''moves to named position'''
        try:
            goal = self.named_positions.get(name.lower())
            if goal is not None:
                self.dev.set_pos(int(goal))
            self.logger.debug("goto_named_pos: %s -> %s",name,goal)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"Move to Named Position": "Failed", "Error": f"{e}"}
        return {"move": "Success"}

    def get_named_position(self):
        '''returns current named position'''
        current = (
            round(self.dev.get_pos(channel=1), 3),
            round(self.dev.get_pos(channel=2), 3),
        )
        for name, pos in self.named_positions.items():
            if pos == current:
                return {"named_pos": name}
        return {"named_pos": "Unknown"}

if __name__ == "__main__":
    Yjpiaagim().serve()

