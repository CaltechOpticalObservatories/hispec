#!/usr/bin/python3.12
'''Module for the ATC Filter Wheel Daemon'''
import argparse
import sys
from typing import Dict, Any

from hispec.daemon import HispecDaemon #pylint: disable = E0401,E0611
from hispec.util.thorlabs.fw102c import FilterWheelController #pylint: disable = E0401,E0611
#from fw102c import FilterWheelController  # Assuming fw102c.py is in the same directory

class Atcfwheel(HispecDaemon): #pylint: disable = W0223
    '''Daemon for controlling the ATC Filter Wheel via Thorlabs FW102C controller'''

    # Defaults
    peer_id = "atcfwheel"
    group_id = "hsfei"
    transport = "rabbitmq"
    discovery_enabled = False
    daemon_desc = "ATC FWheel"

    # pub/sub topics
    topics = {}

    def __init__(self):
        """Initialize the pickoff daemon.

        Args: come from the hsfei configuration file
        """
        super().__init__()

        self.host = self.get_config("hardware.host", "192.168.29.100")
        self.port = self.get_config("hardware.port", 10001)
        self.device_key = None
        self.dev = FilterWheelController()
        self.daemon_desc = "ATC Filter Wheel Daemon"

        # Daemon state
        self.state = {
            'connected': False,
            'error': ''
        }

        # Call parent __init__ first
        super().__init__()

    def get_named_positions(self):
        """Get named positions from config (e.g., home, deployed, science)."""
        return self._config.get("named_positions", {})

    def get_named_position(self, name: str):
        """Get a specific named position value, or None if not found."""
        return self.get_named_positions().get(name)

    def on_start(self, libby):
        '''Starts up daemon and initializies the hardware device'''
        self.logger.info("Starting %s Daemon", self.daemon_desc)
        self.add_services({
            "connect":      lambda p: self.connect(),
            "disconnect":   lambda p: self.disconnect(),
            "initialize":   lambda p: self.initialize(),
            "status":       lambda p: self.status(),
            "position.get": lambda p: self.get_pos(),
            "position.set": lambda p: self.set_pos(pos = p.get("position")),
            "position.get_named": lambda p: self.get_named_position(),
            "position.set_named": lambda p: self.goto_named_pos(name = p.get("named_pos"))
        })
        # Initialize hardware connection
        if self.host is None or self.port is None:
            self.logger.error("No IP address or port specified for ATC Filter Wheel controller")
            self.state['error'] = 'No IP address or port specified'
        else:
            try:
                connection = self.connect()
                if connection.get("Connect") != "Success":
                    raise ConnectionError(connection.get("Error"))
                self.state['connected'] = True
                self.logger.info("Daemon started successfully and connected to hardware")
                self.initialize()
                self.logger.info("Initialized %s", self.daemon_desc)
            except ConnectionRefusedError as e:
                self.logger.error("Failed to connect to hardware: %s", e)
                self.logger.warning("Daemon will start but hardware is not available")
                self.state['error'] = str(e)
                self.state['connected'] = False

        # Publish initial status
        libby.publish("atcfwheel.status", self.state)

    def on_stop(self, libby) -> None: #pylint: disable=W0222
        '''Stops the daemon and disconnects from hardware device'''
        try:
            self.disconnect()
            self.logger.info("Disconnected %s", self.daemon_desc)
            libby.publish("atcfwheel", {"Daemon Shutdown": "Success"})
        except Exception as e: # pylint: disable=W0718
            libby.publish("atcfwheel", {"Daemon Startup": "Failed", "Error":f"{e}"})
            self.logger.error("Disconnect %s:: Failed ", self.daemon_desc)


    def connect(self):
        """handles connection"""
        try:
            self.dev.connect(host = self.host, port = self.port)
            if not self.dev.is_connected():
                raise ConnectionError("Failed to connect to device")
            self.logger.info("Connected %s", self.daemon_desc)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Failed to Connect to Hardware: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok": True, "message": "Connected to hardware"}

    def disconnect(self):
        """handles disconnection"""
        try:
            self.dev.disconnect()
            if self.dev.is_connected():
                raise ConnectionAbortedError("Failed to disconnect to device")
            self.logger.info("Disconnected from %s", self.daemon_desc)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok": True, "message": "Disconnected from hardware"}

    def initialize(self):
        """handles initialization"""
        if not self.state['connected']:
            return {"ok": False, "error": "Not connected to hardware"}

        # for PPC102_Coms, this involves setting the enabled status
        try:
            self.dev.initialize()
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok":False , "error": str(e)}
        return {"ok": True}

    def status(self):
        """handles status"""
        try:
            status = self.dev.get_status()
            self.logger.debug("status: %s",status)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok": True, "status": status}

    def get_pos(self):
        '''gets current position'''
        if not self.state['connected']:
            return {"ok": False, "error": "Not connected to hardware"}

        try:
            position = self.dev.get_pos()
            self.logger.debug("get_pos: %s",position)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok":True, "position": str(position)}

    def set_pos(self, pos):
        '''sets current position'''
        if not self.state['connected']:
            return {"ok": False, "error": "Not connected to hardware"}

        try:
            pos = int(pos)
            self.dev.set_pos(pos)
            self.logger.debug("set_pos: %d",pos)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok": True, "position": pos}

    def goto_named_pos(self, name):
        '''moves to named position'''
        if not self.state['connected']:
            return {"ok": False, "error": "Not connected to hardware"}

        try:
            goal = self.get_named_position(name.lower())
            if goal is not None:
                self.dev.set_pos(int(goal))
            self.logger.debug("goto_named_pos: %s -> %s",name,goal)
        except Exception as e: # pylint: disable=W0718
            self.logger.error("Error: %s",e)
            return {"ok": False, "error": str(e)}
        return {"ok": True, "named_position": name, "position": goal}

if __name__ == "__main__":
    Atcfwheel().serve()
